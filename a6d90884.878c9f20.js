(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{80:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return b}));var r=t(3),a=t(7),i=(t(0),t(91)),o={id:"introduction",title:"DOM Generator",sidebar_label:"Introduction to DOM Generator",description:"DOM relations generator algorithm",keywords:["algorithm","docs","DOM","dflex"]},l={unversionedId:"dom-gen/introduction",id:"dom-gen/introduction",isDocsHomePage:!1,title:"DOM Generator",description:"DOM relations generator algorithm",source:"@site/docs\\dom-gen\\intro.md",slug:"/dom-gen/introduction",permalink:"/dflex/docs/dom-gen/introduction",editUrl:"https://github.com/jalal246/dflex/edit/master/docs/docs/dom-gen/intro.md",version:"current",sidebar_label:"Introduction to DOM Generator",sidebar:"someSidebar",previous:{title:"Contributing",permalink:"/dflex/docs/getting-started/contributing"},next:{title:"DOM Store",permalink:"/dflex/docs/dom-store/introduction"}},c=[{value:"Installation",id:"installation",children:[]},{value:"Generate element pointer",id:"generate-element-pointer",children:[{value:"Auto connect",id:"auto-connect",children:[]}]},{value:"Dealing with branches",id:"dealing-with-branches",children:[{value:"Getting branches",id:"getting-branches",children:[]},{value:"Updating branches",id:"updating-branches",children:[]}]}],s={toc:c};function b(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"DOM relations generator algorithm.")),Object(i.b)("p",null,"Dom generator generates relations between DOM elements based on element depth\nwithout a browser.\nIt generates three keys: Siblings, Parent and Children keys and two\nindexes one refers to node order in its level and the other refers to the parent\nindex in parental level."),Object(i.b)("p",null,"Together: keys and indexes combined form of uniqueness for each element."),Object(i.b)("h2",{id:"installation"},"Installation"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),"npm install @dflex/dom-gen\n")),Object(i.b)("p",null,"In case you are dealing with any DOM-tree, you can build entire branches and traverse\nthrough them using these generated unique keys and indexes. Think of relational\ndatabase or hash tables but applied in DOM tree."),Object(i.b)("h2",{id:"generate-element-pointer"},"Generate element pointer"),Object(i.b)("p",{align:"center"},Object(i.b)("img",{src:"https://raw.githubusercontent.com/jalal246/dflex/master/packages/dom-gen/img/pointer.png",alt:"how pointer works"})),Object(i.b)("p",null,"Element pointer refers to the element position and its relationship in DOM tree.\nIt's represented with ",Object(i.b)("inlineCode",{parentName:"p"},"getElmPointer")," as following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"const domGen = new Generator()\n\ndomGen.getElmPointer(id: string, depth: number)\n")),Object(i.b)("p",null,"Returns pointer object refers to element relation with its keys and related\nindex:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"order: Object <elementOrder>")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"self: number")," - Element self index among its siblings."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"parent: number")," - Parent index among its siblings."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"keys: Object <relationKey>")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"sK: string")," - Siblings Key, connects nodes in the same level."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pK: string")," - Parent key, connects nodes in the higher level."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"chK: string")," - Children Key, connects nodes in the lower level.")))),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'import Generator from "@dflex/dom-gen";\n\nconst domGen = new Generator();\n\nlet pointer = domGen.getElmPointer("id-0", 0);\n\n// pointer = {\n//   keys: {\n//     chK: null,\n//     pK: "1-0",\n//     sK: "0-0",\n//   },\n//   order: {\n//     parent: 0,\n//     self: 0,\n//   },\n// };\n')),Object(i.b)("p",null,"Internally ",Object(i.b)("inlineCode",{parentName:"p"},"Generator")," has build dom tree as following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),'DOM-root\n\u2502\n\u2502\u2500\u2500\u2500id-0 => order: { parent: 0, self: 0 } || keys: { chK: null , pK: "1-0", sK: "0-0" }\n')),Object(i.b)("p",null,"Adding more elements on the same level:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const pointer1 = domGen.getElmPointer("id-1", 0);\n\n// pointer1 = {\n//   keys: {\n//     chK: null,\n//     pK: "1-0",\n//     sK: "0-0",\n//   },\n//   order: {\n//     parent: 0,\n//     self: 1,\n//   },\n// };\n\nconst pointer2 = domGen.getElmPointer("id-2", 0);\n\n// pointer2 = {\n//   keys: {\n//     chK: null,\n//     pK: "1-0",\n//     sK: "0-0",\n//   },\n//   order: {\n//     parent: 0,\n//     self: 2,\n//   },\n// };\n')),Object(i.b)("p",null,"And dom tree is:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),'DOM-root\n\u2502\n\u2502\u2500\u2500\u2500id-0 => order: {parent: 0, self: 0} || keys: {chK: null, pK: "1-0", sK: "0-0"}\n\u2502\n\u2502\u2500\u2500\u2500id-1 => order: {parent: 0, self: 1} || keys: {chK: null, pK: "1-0", sK: "0-0"}\n\u2502\n\u2502\u2500\u2500\u2500id-2 => order: {parent: 0, self: 2} || keys: {chK: null, pK: "1-0", sK: "0-0"}\n')),Object(i.b)("h3",{id:"auto-connect"},"Auto connect"),Object(i.b)("p",{align:"center"},Object(i.b)("img",{src:"https://raw.githubusercontent.com/jalal246/dflex/master/packages/dom-gen/img/connect.png",alt:"how algorithm connect nodes"})),Object(i.b)("p",null,"ids form 0 to 2, all have same parent and siblings key. And it guarantees that\nany any incoming parent will carry key ",Object(i.b)("inlineCode",{parentName:"p"},"1-0")," and exists in the same position ",Object(i.b)("inlineCode",{parentName:"p"},"0"),"."),Object(i.b)("p",null,"This goes also for any parent. Eventually, by using keys and indexes you can go up\u2191\nand down\u2193."),Object(i.b)("p",null,"Following the same logic we can go deeper:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const pointer = domGen.getElmPointer("id-parent-1", 1);\n\n// pointer = {\n//   keys: {\n//     chK: "0-0",\n//     pK: "2-0",\n//     sK: "1-0", // this key was generated previously in children level.\n//   },\n//   order: {\n//     parent: 0, // all children aware of their parent index.\n//     self: 0,\n//   },\n// };\n')),Object(i.b)("p",null,"Changing the depth identifies new level. Take a look at current dom tree that we\nnow have:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-bash"}),'DOM-root\n\u251c\u2500\u2500\u2500id-parent-1  => order: {parent: 0, self: 0} || keys: {chK: "0-0", pK: "2-0", sK: "1-0"}\n    |\n    \u2502\u2500\u2500\u2500id-0  => order: {parent: 0, self: 0} || keys: {chK: null, pK: "1-0", sK: "0-0"}\n    \u2502\n    \u2502\u2500\u2500\u2500id-1 => ..\n    \u2502\n    \u2502\u2500\u2500\u2500id-2 => ..\n\n')),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Take into consideration some major points:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"It works both ascending and descending. So, it doesn't care how nodes are\nmounted and it works with async mounting.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"It automatically attaches the tree and links each node to the suitable parent\nand siblings."))),Object(i.b)("h2",{id:"dealing-with-branches"},"Dealing with branches"),Object(i.b)("p",null,"Despite the fact that ",Object(i.b)("inlineCode",{parentName:"p"},"Generator")," is not DOM store, it maintains some kind of\ndata to keep generate unique pointers. Every incoming node element belong to\nbranch contains all input ids distrusted by depth/level entries."),Object(i.b)("h3",{id:"getting-branches"},"Getting branches"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"domGen.getElmBranch(sk: string) : string<id> | Array<ids>\n")),Object(i.b)("p",null,"where ",Object(i.b)("inlineCode",{parentName:"p"},"sk")," represents siblings key generated by ",Object(i.b)("inlineCode",{parentName:"p"},"getElmPointer"),". Going back to\nour generated tree:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const branchChildren = domGen.getElmBranch("0-0");\n\n// branchChildren = ["id-0", "id-1", "id-2"];\n')),Object(i.b)("p",null,"Since we have only one parent ",Object(i.b)("inlineCode",{parentName:"p"},"branchParents")," contain one node only:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const branchParents = domGen.getElmBranch("1-0");\n\n// branchParents = "id-parent-1";\n')),Object(i.b)("p",null,"To get all branches:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const { branches } = domGen;\n\n// branches = {\n//   "0-0": ["id-0", "id-1", "id-2"],\n//   "1-0": "id-parent-1",\n// };\n')),Object(i.b)("h3",{id:"updating-branches"},"Updating branches"),Object(i.b)("p",null,"There's no point in having DOM treemap without the ability to update it\naccording to some logic you've already implemented in your app. Following common\nsense, you can do it easily with ",Object(i.b)("inlineCode",{parentName:"p"},"setElmBranch"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"domGen.setElmBranch(sk: string, branch: string<id>|Array<ids>)\n")),Object(i.b)("p",null,"Let's continue working on our branches by switching the order of children.\nCurrently, we have: ",Object(i.b)("inlineCode",{parentName:"p"},'"0-0": ["id-0", "id-1", "id-2"]')," but element with ",Object(i.b)("inlineCode",{parentName:"p"},"id-1"),"\nhas been switched with ",Object(i.b)("inlineCode",{parentName:"p"},"id-2"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const { branches } = domGen;\n\nconst newBranch = ["id-0", "id-2", "id-1"];\n\ndomGen.setElmBranch("0-0", newBranch);\n\n// branches = {\n//   "0-0": ["id-0", "id-2", "id-1"],\n//   "1-0": "id-parent-1",\n// };\n')))}b.isMDXComponent=!0},91:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return u}));var r=t(0),a=t.n(r);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=a.a.createContext({}),b=function(e){var n=a.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=b(e.components);return a.a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},m=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=b(t),m=r,u=d["".concat(o,".").concat(m)]||d[m]||p[m]||i;return t?a.a.createElement(u,l(l({ref:n},s),{},{components:t})):a.a.createElement(u,l({ref:n},s))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);